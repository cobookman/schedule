<!doctype html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>all - jStat Documentation</title>
	<link rel="stylesheet" href="assets/style.css" />
	<link rel="stylesheet" href="assets/sh.css" />
</head>
<body>
	<div id="container">
    <header>
      <h1>jStat Documentation</h1>
      <div id="gtoc">
        <p><a href="index.html">Index</a> | <a href="all.html">View on single page</a></p>
      </div>
      <hr />
    </header>
	<div id="toc"><h2>Table Of Contents</h2><ul><li><a href="#overview">Overview</a><ul><li><a href="#description">Description</a></li><li><a href="#architecture">Architecture</a></li></ul></li><li><a href="#core_Functionality">Core Functionality</a><ul><li><a href="#jStat">jStat()</a></li><li><a href="#rows">rows()</a></li><li><a href="#cols">cols()</a></li><li><a href="#dimensions">dimensions()</a></li><li><a href="#row">row()</a></li><li><a href="#col">col()</a></li><li><a href="#diag">diag()</a></li><li><a href="#antidiag">antidiag()</a></li><li><a href="#transpose">transpose()</a></li><li><a href="#map">map( func )</a></li><li><a href="#alter">alter( func )</a></li><li><a href="#create">create()</a></li><li><a href="#zeros">zeros()</a></li><li><a href="#ones">ones()</a></li><li><a href="#rand">rand()</a></li><li><a href="#identity">identity()</a></li><li><a href="#clear">clear()</a></li><li><a href="#symmetric">symmetric()</a></li></ul></li><li><a href="#jStat_Utility_Methods">jStat Utility Methods</a><ul><li><a href="#utils.calcRdx">utils.calcRdx( num0, num1 )</a></li><li><a href="#utils.isArray">utils.isArray( arg )</a></li><li><a href="#utils.isFunction">utils.isFunction( arg )</a></li><li><a href="#utils.isNumber">utils.isNumber( arg )</a></li></ul></li><li><a href="#vector_Functionality">Vector Functionality</a><ul><li><a href="#sum">sum()</a></li><li><a href="#sumsqrd">sumsqrd()</a></li><li><a href="#sumsqerr">sumsqerr()</a></li><li><a href="#product">product()</a></li><li><a href="#min">min()</a></li><li><a href="#max">max()</a></li><li><a href="#mean">mean()</a></li><li><a href="#meansqerr">meansqerr()</a></li><li><a href="#geomean">geomean()</a></li><li><a href="#median">median()</a></li><li><a href="#cumsum">cumsum()</a></li><li><a href="#diff">diff()</a></li><li><a href="#mode">mode()</a></li><li><a href="#range">range()</a></li><li><a href="#variance">variance()</a></li><li><a href="#stdev">stdev()</a></li><li><a href="#meandev">meandev()</a></li><li><a href="#meddev">meddev()</a></li><li><a href="#coeffvar">coeffvar()</a></li><li><a href="#quartiles">quartiles()</a></li><li><a href="#covariance">covariance()</a></li><li><a href="#corrcoeff">corrcoeff()</a></li></ul></li><li><a href="#distributions">Distributions</a><ul><li><a href="#jStat.beta">jStat.beta( alpha, beta )</a><ul><li><a href="#jStat.beta.pdf">jStat.beta.pdf( x, alpha, beta )</a></li><li><a href="#jStat.beta.cdf">jStat.beta.cdf( x, alpha, beta )</a></li><li><a href="#jStat.beta.inv">jStat.beta.inv( p, alpha, beta )</a></li><li><a href="#jStat.beta.mean">jStat.beta.mean( alpha, beta )</a></li><li><a href="#jStat.beta.median">jStat.beta.median( alpha, beta )</a></li><li><a href="#jStat.beta.mode">jStat.beta.mode( alpha, beta )</a></li><li><a href="#jStat.beta.sample">jStat.beta.sample( alpha, beta )</a></li><li><a href="#jStat.beta.variance">jStat.beta.variance( alpha, beta )</a></li></ul></li><li><a href="#jStat.centralF">jStat.centralF( df1, df2 )</a><ul><li><a href="#jStat.centralF.pdf">jStat.centralF.pdf( x, df1, df2 )</a></li><li><a href="#jStat.centralF.cdf">jStat.centralF.cdf( x, df1, df2 )</a></li><li><a href="#jStat.centralF.inv">jStat.centralF.inv( x, df1, df2 )</a></li><li><a href="#jStat.centralF.mean">jStat.centralF.mean( df1, df2 )</a></li><li><a href="#jStat.centralF.mode">jStat.centralF.mode( df1, df2 )</a></li><li><a href="#jStat.centralF.sample">jStat.centralF.sample( df1, df2 )</a></li><li><a href="#jStat.centralF.variance">jStat.centralF.variance( df1, df2 )</a></li></ul></li><li><a href="#jStat.cauchy">jStat.cauchy( local, scale )</a><ul><li><a href="#jStat.cauchy.pdf">jStat.cauchy.pdf( x, local, scale )</a></li><li><a href="#jStat.cauchy.cdf">jStat.cauchy.cdf( x, local, scale )</a></li><li><a href="#jStat.cauchy.inv">jStat.cauchy.inv( p, local, scale )</a></li><li><a href="#jStat.cauchy.median">jStat.cauchy.median( local, scale )</a></li><li><a href="#jStat.cauchy.mode">jStat.cauchy.mode( local, scale )</a></li><li><a href="#jStat.cauchy.sample">jStat.cauchy.sample( local, scale )</a></li><li><a href="#jStat.cauchy.variance">jStat.cauchy.variance( local, scale )</a></li></ul></li><li><a href="#jStat.chisquare">jStat.chisquare( dof )</a><ul><li><a href="#jStat.chisquare.pdf">jStat.chisquare.pdf( x, dof )</a></li><li><a href="#jStat.chisquare.cdf">jStat.chisquare.cdf( x, dof )</a></li><li><a href="#jStat.chisquare.inv">jStat.chisquare.inv( p, dof )</a></li><li><a href="#jStat.chisquare.mean">jStat.chisquare.mean( dof )</a></li><li><a href="#jStat.chisquare.median">jStat.chisquare.median( dof )</a></li><li><a href="#jStat.chisquare.mode">jStat.chisquare.mode( dof )</a></li><li><a href="#jStat.chisquare.sample">jStat.chisquare.sample( dof )</a></li><li><a href="#jStat.chisquare.variance">jStat.chisquare.variance( dof )</a></li></ul></li><li><a href="#jStat.exponential">jStat.exponential( rate )</a><ul><li><a href="#jStat.exponential.pdf">jStat.exponential.pdf( x, rate )</a></li><li><a href="#jStat.exponential.cdf">jStat.exponential.cdf( x, rate )</a></li><li><a href="#jStat.exponential.inv">jStat.exponential.inv( rate )</a></li><li><a href="#jStat.exponential.mean">jStat.exponential.mean( rate )</a></li><li><a href="#jStat.exponential.median">jStat.exponential.median( rate )</a></li><li><a href="#jStat.exponential.mode">jStat.exponential.mode( rate )</a></li><li><a href="#jStat.exponential.sample">jStat.exponential.sample( rate )</a></li><li><a href="#jStat.exponential.variance">jStat.exponential.variance( rate )</a></li></ul></li><li><a href="#jStat.gamma">jStat.gamma( shape, scale )</a><ul><li><a href="#jStat.gamma.pdf">jStat.gamma.pdf( x, shape, scale )</a></li><li><a href="#jStat.gamma.cdf">jStat.gamma.cdf( x, shape, scale )</a></li><li><a href="#jStat.gamma.inv">jStat.gamma.inv( p, shape, scale )</a></li><li><a href="#jStat.gamma.mean">jStat.gamma.mean( shape, scale )</a></li><li><a href="#jStat.gamma.mode">jStat.gamma.mode( shape, scale )</a></li><li><a href="#jStat.gamma.sample">jStat.gamma.sample( shape, scale )</a></li><li><a href="#jStat.gamma.variance">jStat.gamma.variance( shape, scale )</a></li></ul></li><li><a href="#jStat.invgamma">jStat.invgamma( shape, scale )</a><ul><li><a href="#jStat.invgamma.pdf">jStat.invgamma.pdf( x, shape, scale )</a></li><li><a href="#jStat.invgamma.cdf">jStat.invgamma.cdf( x, shape, scale )</a></li><li><a href="#jStat.invgamma.inv">jStat.invgamma.inv( p, shape, scale )</a></li><li><a href="#jStat.invgamma.mean">jStat.invgamma.mean( shape, scale )</a></li><li><a href="#jStat.invgamma.mode">jStat.invgamma.mode( shape, scale )</a></li><li><a href="#jStat.invgamma.sample">jStat.invgamma.sample( shape, scale )</a></li><li><a href="#jStat.invgamma.variance">jStat.invgamma.variance( shape, scale )</a></li></ul></li><li><a href="#jStat.kumaraswamy">jStat.kumaraswamy( alpha, beta )</a><ul><li><a href="#jStat.kumaraswamy.pdf">jStat.kumaraswamy.pdf( x, a, b )</a></li><li><a href="#jStat.kumaraswamy.cdf">jStat.kumaraswamy.cdf( x, alpha, beta )</a></li><li><a href="#jStat.kumaraswamy.mean">jStat.kumaraswamy.mean( alpha, beta )</a></li><li><a href="#jStat.kumaraswamy.median">jStat.kumaraswamy.median( alpha, beta )</a></li><li><a href="#jStat.kumaraswamy.mode">jStat.kumaraswamy.mode( alpha, beta )</a></li><li><a href="#jStat.kumaraswamy.variance">jStat.kumaraswamy.variance( alpha, beta )</a></li></ul></li><li><a href="#jStat.lognormal">jStat.lognormal( mu, sigma )</a><ul><li><a href="#jStat.lognormal.pdf">jStat.lognormal.pdf( x, mu, sigma )</a></li><li><a href="#jStat.lognormal.cdf">jStat.lognormal.cdf( x, mu, sigma )</a></li><li><a href="#jStat.lognormal.inv">jStat.lognormal.inv( p, mu, sigma )</a></li><li><a href="#jStat.lognormal.mean">jStat.lognormal.mean( mu, sigma )</a></li><li><a href="#jStat.lognormal.median">jStat.lognormal.median( mu, sigma )</a></li><li><a href="#jStat.lognormal.mode">jStat.lognormal.mode( mu, sigma )</a></li><li><a href="#jStat.lognormal.sample">jStat.lognormal.sample( mu, sigma )</a></li><li><a href="#jStat.lognormal.variance">jStat.lognormal.variance( mu, sigma )</a></li></ul></li><li><a href="#jStat.normal">jStat.normal( mean, std )</a><ul><li><a href="#jStat.normal.pdf">jStat.normal.pdf( x, mean, std )</a></li><li><a href="#jStat.normal.cdf">jStat.normal.cdf( x, mean, std )</a></li><li><a href="#jStat.normal.inv">jStat.normal.inv( p, mean, std )</a></li><li><a href="#jStat.normal.mean">jStat.normal.mean( mean, std )</a></li><li><a href="#jStat.normal.median">jStat.normal.median( mean, std )</a></li><li><a href="#jStat.normal.mode">jStat.normal.mode( mean, std )</a></li><li><a href="#jStat.normal.sample">jStat.normal.sample( mean, std )</a></li><li><a href="#jStat.normal.variance">jStat.normal.variance( mean, std )</a></li></ul></li><li><a href="#jStat.pareto">jStat.pareto( scale, shape )</a><ul><li><a href="#jStat.pareto.pdf">jStat.pareto.pdf( x, scale, shape )</a></li><li><a href="#jStat.pareto.cdf">jStat.pareto.cdf( x, scale, shape )</a></li><li><a href="#jStat.pareto.mean">jStat.pareto.mean( scale, shape )</a></li><li><a href="#jStat.pareto.median">jStat.pareto.median( scale, shape )</a></li><li><a href="#jStat.pareto.mode">jStat.pareto.mode( scale, shape )</a></li><li><a href="#jStat.pareto.variance">jStat.pareto.variance( scale, shape )</a></li></ul></li><li><a href="#jStat.studentt">jStat.studentt( dof )</a><ul><li><a href="#jStat.studentt.pdf">jStat.studentt.pdf( x, dof )</a></li><li><a href="#jStat.studentt.cdf">jStat.studentt.cdf( x, dof )</a></li><li><a href="#jStat.studentt.inv">jStat.studentt.inv( p, dof )</a></li><li><a href="#jStat.studentt.mean">jStat.studentt.mean( dof )</a></li><li><a href="#jStat.studentt.median">jStat.studentt.median( dof )</a></li><li><a href="#jStat.studentt.mode">jStat.studentt.mode( dof )</a></li><li><a href="#jStat.studentt.sample">jStat.studentt.sample( dof )</a></li><li><a href="#jStat.studentt.variance">jStat.studentt.variance( dof )</a></li></ul></li><li><a href="#jStat.weibull">jStat.weibull( scale, shape )</a><ul><li><a href="#jStat.weibull.pdf">jStat.weibull.pdf( x, scale, shape )</a></li><li><a href="#jStat.weibull.cdf">jStat.weibull.cdf( x, scale, shape )</a></li><li><a href="#jStat.weibull.inv">jStat.weibull.inv( p, scale, shape )</a></li><li><a href="#jStat.weibull.mean">jStat.weibull.mean( scale, shape )</a></li><li><a href="#jStat.weibull.median">jStat.weibull.median( scale, shape )</a></li><li><a href="#jStat.weibull.mode">jStat.weibull.mode( scale, shape )</a></li><li><a href="#jStat.weibull.sample">jStat.weibull.sample( scale, shape )</a></li><li><a href="#jStat.weibull.variance">jStat.weibull.variance( scale, shape )</a></li></ul></li><li><a href="#jStat.uniform">jStat.uniform( a, b )</a><ul><li><a href="#jStat.uniform.pdf">jStat.uniform.pdf( x, a, b )</a></li><li><a href="#jStat.uniform.cdf">jStat.uniform.cdf( x, a, b )</a></li><li><a href="#jStat.uniform.mean">jStat.uniform.mean( a, b )</a></li><li><a href="#jStat.uniform.median">jStat.uniform.median( a, b )</a></li><li><a href="#jStat.uniform.mode">jStat.uniform.mode( a, b )</a></li><li><a href="#jStat.uniform.sample">jStat.uniform.sample( a, b )</a></li><li><a href="#jStat.uniform.variance">jStat.uniform.variance( a, b )</a></li></ul></li><li><a href="#jStat.binomial">jStat.binomial</a><ul><li><a href="#jStat.binomial.pdf">jStat.binomial.pdf( k, n, p )</a></li><li><a href="#jStat.binomial.cdf">jStat.binomial.cdf( k, n, p )</a></li></ul></li><li><a href="#jStat.negbin">jStat.negbin</a><ul><li><a href="#jStat.negbin.pdf">jStat.negbin.pdf( k, r, p )</a></li><li><a href="#jStat.negbin.cdf">jStat.negbin.cdf( x, r, p )</a></li></ul></li><li><a href="#jStat.hypgeom">jStat.hypgeom</a><ul><li><a href="#jStat.hypgeom.pdf">jStat.hypgeom.pdf( k, N, m, n )</a></li><li><a href="#jStat.hypgeom.cdf">jStat.hypgeom.cdf( x, N, m, n )</a></li></ul></li><li><a href="#jStat.poisson">jStat.poisson</a><ul><li><a href="#jStat.poisson.pdf">jStat.poisson.pdf( k, l )</a></li><li><a href="#jStat.poisson.cdf">jStat.poisson.cdf( x, l )</a></li></ul></li><li><a href="#jStat.triangular">jStat.triangular</a><ul><li><a href="#jStat.triangular.pdf">jStat.triangular.pdf( x, a, b, c )</a></li><li><a href="#jStat.triangular.cdf">jStat.triangular.cdf( x, a, b, c )</a></li><li><a href="#jStat.triangular.mean">jStat.triangular.mean( a, b, c )</a></li><li><a href="#jStat.triangular.median">jStat.triangular.median( a, b, c )</a></li><li><a href="#jStat.triangular.mode">jStat.triangular.mode( a, b, c )</a></li><li><a href="#jStat.triangular.variance">jStat.triangular.variance( a, b, c )</a></li></ul></li></ul></li><li><a href="#special_Functions">Special Functions</a><ul><li><a href="#betafn">betafn( x, y )</a></li><li><a href="#betaln">betaln( x, y )</a></li><li><a href="#betacf">betacf( x, a, b )</a></li><li><a href="#ibetainv">ibetainv( p, a, b)</a></li><li><a href="#ibeta">ibeta( x, a, b)</a></li><li><a href="#gammaln">gammaln( x )</a></li><li><a href="#gammafn">gammafn( x )</a></li><li><a href="#gammap">gammap( a, x )</a></li><li><a href="#factorialln">factorialln( n )</a></li><li><a href="#factorial">factorial( n )</a></li><li><a href="#combination">combination( n, m )</a></li><li><a href="#permutation">permutation( n, m )</a></li><li><a href="#gammapinv">gammapinv( p, a )</a></li><li><a href="#erf">erf( x )</a></li><li><a href="#erfc">erfc( x )</a></li><li><a href="#erfcinv">erfcinv( p )</a></li><li><a href="#randn">randn( n, m )</a></li><li><a href="#randg">randg( shape, n, m )</a></li></ul></li><li><a href="#linear_Algebra">Linear Algebra</a></li><li><a href="#instance_Functionality">Instance Functionality</a><ul><li><a href="#add">add( arg )</a></li><li><a href="#subtract">subtract( arg )</a></li><li><a href="#divide">divide( arg )</a></li><li><a href="#multiply">multiply( arg )</a></li><li><a href="#dot">dot( arg )</a></li><li><a href="#pow">pow( arg )</a></li><li><a href="#abs">abs()</a></li><li><a href="#norm">norm()</a></li><li><a href="#angle">angle( arg )</a></li></ul></li><li><a href="#static_Functionality">Static Functionality</a><ul><li><a href="#add">add( arr, arg )</a></li><li><a href="#subtract">subtract( arr, arg )</a></li><li><a href="#divide">divide( arr, arg )</a></li><li><a href="#multiply">multiply( arr, arg )</a></li><li><a href="#dot">dot( arr1, arr2 )</a></li><li><a href="#pow">pow( arr, arg )</a></li><li><a href="#abs">abs(arr)</a></li><li><a href="#norm">norm(arr)</a></li><li><a href="#angle">angle( arr1, arr2 )</a></li><li><a href="#aug">aug(A,B)</a></li><li><a href="#det">det(A)</a></li><li><a href="#inv">inv(A)</a></li><li><a href="#gauss_elimination">gauss_elimination(A,B)</a></li><li><a href="#gauss_jordan">gauss_jordan(A,B)</a></li><li><a href="#lu">lu(A,B)</a></li><li><a href="#cholesky">cholesky(A)</a></li><li><a href="#gauss_jacobi">gauss_jacobi(A,b,x,r)</a></li><li><a href="#gauss_seidel">gauss_seidel(A,b,x,r)</a></li><li><a href="#sOR">SOR(A,b,x,r,w)</a></li><li><a href="#householder">householder(A)</a></li><li><a href="#qR">QR()</a></li><li><a href="#jacobi">jacobi()</a></li><li><a href="#rungekutta">rungekutta()</a></li><li><a href="#romberg">romberg()</a></li><li><a href="#richardson">richardson()</a></li><li><a href="#simpson">simpson()</a></li><li><a href="#hermite">hermite()</a></li><li><a href="#lagrange">lagrange()</a></li><li><a href="#cubic_spline">cubic_spline()</a></li><li><a href="#gauss_quadrature">gauss_quadrature()</a></li><li><a href="#pCA">PCA()</a></li></ul></li><li><a href="#statistical_Tests">Statistical Tests</a></li><li><a href="#statistics_Instance_Functionality">Statistics Instance Functionality</a><ul><li><a href="#zscore">zscore( value[, flag])</a></li><li><a href="#ztest">ztest( value, sides[, flag])</a></li><li><a href="#tscore">tscore( value)</a></li><li><a href="#ttest">ttest( value, sides)</a></li><li><a href="#anovafscore">anovafscore()</a></li><li><a href="#anovaftest">anovaftest()</a></li></ul></li><li><a href="#static_Methods_">Static Methods </a></li><li><a href="#z_Statistics">Z Statistics</a><ul><li><a href="#jStat.zscore">jStat.zscore( value, mean, sd)</a></li><li><a href="#jStat.zscore">jStat.zscore( value, array[, flag])</a></li><li><a href="#jStat.ztest">jStat.ztest( value, mean, sd, sides)</a></li><li><a href="#jStat.ztest">jStat.ztest( zscore, sides)</a></li><li><a href="#jStat.ztest">jStat.ztest( value, array, sides[, flag])</a></li></ul></li><li><a href="#t_Statistics">T Statistics</a><ul><li><a href="#jStat.tscore">jStat.tscore( value, mean, sd, n)</a></li><li><a href="#jStat.tscore">jStat.tscore( value, array)</a></li><li><a href="#jStat.ttest">jStat.ttest( value, mean, sd, n, sides)</a></li><li><a href="#jStat.ttest">jStat.ttest( tscore, n, sides)</a></li><li><a href="#jStat.ttest">jStat.ttest( value, array, sides)</a></li></ul></li><li><a href="#f_Statistics">F Statistics</a><ul><li><a href="#jStat.anovafscore">jStat.anovafscore( array1, array2, ..., arrayn)</a></li><li><a href="#jStat.anovafscore">jStat.anovafscore( [array1,array2, ...,arrayn])</a></li><li><a href="#jStat.anovaftest">jStat.anovaftest( array1, array2, ...., arrayn)</a></li><li><a href="#jStat.ftest">jStat.ftest( fscore, df1, df2)</a></li></ul></li><li><a href="#confidence_Intervals">Confidence Intervals</a><ul><li><a href="#jStat.normalci">jStat.normalci( value, alpha, sd, n)</a></li><li><a href="#jStat.normalci">jStat.normalci( value, alpha, array)</a></li><li><a href="#jStat.tci">jStat.tci( value, alpha, sd, n)</a></li><li><a href="#jStat.tci">jStat.tci( value, alpha, array)</a></li></ul></li></ul><hr /></div>
<h2 id="overview">Overview</h2>

<h3 id="description">Description</h3>

<p>jStat is a statistical library written in JavaScript that allows you to perform advanced statistical operations without the need of a dedicated statistical language (e.g. MATLAB or R).</p>

<h3 id="architecture">Architecture</h3>

<p>Calculations are done by <em>static methods</em>, while working with groups of numbers is handled by the <em>instance methods</em>.
Here is a pseudo example of what is happening in <code>core.js</code>:</p>

<pre><code>jStat.min = function( arr ) {
    return Math.min.apply( null, arr );
}

jStat.prototype.min = function() {
    var i = 0,
        newval = [];
    while( newval.push( jStat.min( this[i] )), ++i &lt; this.length );
    return newval;
}</code></pre>

<p><code>jStat.min</code> does the actual calculation on the array, while <code>jStat.prototype.min</code> is a wrapper to help work with the jStat object.
The reason for this approach is to allow for maxium flexibility to other developers who want to extend jStat, while allowing for easy creation of wrappers.
This way extending jStat requires minimal performance overhead and allows for more unique wrappers to be created.</p>

<p><strong>Remember: Static methods almost always return native JavaScript types. Instance methods always return a jStat object.</strong></p>

<p>Here is a simple example on the difference in usage between the static and instance methods:</p>

<pre><code>var myVect = [2,6,4,7,2,7,4],
    jObj = jStat( myVect );

// calculate the sum of the the vector
jStat.sum( myVect ) === 32;
jObj.sum() === 32;</code></pre>

<p>Now say we want to do several operations on the vector (e.g. sum, min, max, and standard deviation).
This can be accomplished using the static methods, but each will need to be called separately.
By using the jStat object we can pass callback functions and chain the execution of each operation:</p>

<pre><code>jObj.sum( function( val ) {
    // val === sum
}).min( function( val ) {
    // val === min
}).max( function( val ) {
    // val === max
}).stdev( function( val ) {
    // val === st. dev.
});</code></pre>

<p>This method sets each calculation to be executed in an asynchronous queue.
Very useful method of preventing blocking when working with large data sets.</p>

<p>Let&#39;s look at a few chaining and shorthand examples:</p>

<pre><code>jStat( 0, 1, 11 ) === jStat( jStat.seq( 0, 1, 11 ));
jStat().rand( 4, 4 ) === jStat( jStat.rand( 4, 4 ));

jStat().create( 5, function( x, y ) {
    return ( x + Math.random()) / ( y + Math.random());
}).min( true, function( x ) {
    // do something with the min value
}).beta( 0.5, 0.5 ).pdf();  // generate and return the pdf
                            // of the beta function for all values</code></pre>

<h2 id="core_Functionality">Core Functionality</h2>

<p>Core functionality include methods that generate and analyse vectors or matrices.</p>

<h3 id="jStat">jStat()</h3>

<p>The jStat object can function in several capacities, as demonstrated below.
In all cases, jStat will always return an instance of itself.</p>

<p><strong>jStat( array[, fn] )</strong></p>

<p>Create a new jStat object from either an existing array or jStat object.
For example, create a new jStat matrix by doing the following:</p>

<pre><code>var matrix = jStat([[ 1, 2, 3 ],[ 4, 5, 6 ],[ 7, 8, 9 ]]);</code></pre>

<p>If an existing jStat object is passed as an argument then it will be cloned into a new object:</p>

<pre><code>var stat1 = jStat([[ 1, 2 ],[ 3, 4 ]]),
    stat2 = jStat( stat1 );</code></pre>

<p>To transform the data on creation, pass a function as the final argument:</p>

<pre><code>jStat([[ 1, 2 ],[ 3, 4 ]], function( x ) {
    return x * 2;
});</code></pre>

<p><strong>jStat( start, stop, count[, fn ])</strong></p>

<p>To create a sequence then pass numeric values in the same form <code>jStat.seq()</code> would be used:</p>

<pre><code>var vector = jStat( 0, 1, 5 );
// vector === [[ 0, 0.25, 0.5, 0.75, 1 ]]</code></pre>

<p>By passing a function the sequence value can be manipulated:</p>

<pre><code>var vector = jStat( 0, 1, 5, function( x ) {
    return x * 2;
});
// vector === [[ 0, 0.5, 1, 1.5, 2 ]];</code></pre>

<p>The second argument passed to the function is the count (starting from 0).
Using this we can create a multidimensional array (useful for plotting data):</p>

<pre><code>var betaGraph = jStat( 0, 1, 11, function( x, cnt ) {
    return [ jStat.beta.pdf( x, alpha, beta ), cnt ];
});</code></pre>

<p><strong>jStat()</strong></p>

<p>A chainable shortcut in the API exists to allow for filling in the data after object creation.
So creating <code>jStat</code> objects from methods like <code>rand()</code> can be accomplished in one of the following ways:</p>

<pre><code>// pass the generated random 3x3 matrix to jStat
jStat( jStat.rand( 3 ));
// or create an empty instance that is filled in afterwards
jStat().rand( 3 );</code></pre>

<h3 id="rows">rows()</h3>

<p>Returns the count of rows in a matrix.</p>

<p><strong>rows( array )</strong></p>

<pre><code>var matrix = [[1,2,3],[4,5,6]];
jStat.rows( matrix ) === 2;</code></pre>

<p><strong>fn.rows( [callback] )</strong></p>

<pre><code>jStat( matrix ).rows() === 2;</code></pre>

<p>Or pass a callback to run the calculation asynchronously and pass on the calculation.
This allows for continued chaining of methods to the jStat object.
Also note <code>this</code> within the callback refers to the calling jStat object.</p>

<pre><code>jStat( matrix ).rows(function( d ) {
    // d === 2
});</code></pre>

<h3 id="cols">cols()</h3>

<p>Returns the number of columns in a matrix.</p>

<p><strong>cols( array )</strong></p>

<pre><code>var matrix = [[1,2,3],[4,5,6]];
jStat.cols( matrix ) === 3;</code></pre>

<p><strong>fn.cols( [callback] )</strong></p>

<pre><code>jStat( matrix ).cols() === 3;</code></pre>

<p>Or pass a callback to run the calculation asynchronously and pass on the calculation.
This allows for continued chaining of methods to the jStat object.
Also note <code>this</code> within the callback refers to the calling jStat object.</p>

<pre><code>jStat( matrix ).cols(function( d ) {
    // d === 3
});</code></pre>

<h3 id="dimensions">dimensions()</h3>

<p>Returns and object with the dimensions of a matrix.</p>

<p><strong>dimensions( array )</strong></p>

<pre><code>var matrix = [[1,2,3],[4,5,6]];
jStat.dimensions( matrix ) === { cols: 3, rows: 2 };</code></pre>

<p><strong>fn.dimensions( [callback] )</strong></p>

<pre><code>jStat( matrix ).dimensions() === { cols: 3, rows: 2 };</code></pre>

<p>Or pass a callback to run the calculation asynchronously and pass on the calculation.
This allows for continued chaining of methods to the jStat object.
Also note <code>this</code> within the callback refers to the calling jStat object.</p>

<pre><code>jStat( matrix ).dimensions(function( d ) {
    // d === { cols: 3, rows: 2 }
});</code></pre>

<h3 id="row">row()</h3>

<p>Returns a specified row of a matrix.</p>

<p><strong>row( array, index )</strong></p>

<pre><code>var matrix = [[1,2,3],[4,5,6]];
jStat.row( matrix, 0 ) === [1,2,3];</code></pre>

<p><strong>fn.row( index[, callback] )</strong></p>

<pre><code>jStat( matrix ).row( 0 ) === jStat([1,2,3]);</code></pre>

<p>Or pass a callback to run the calculation asynchronously and pass on the calculation.
This allows for continued chaining of methods to the jStat object.
Also note <code>this</code> within the callback refers to the calling jStat object.</p>

<pre><code>jStat( matrix ).row( 0, function( d ) {
    // d === jStat([1,2,3])
});</code></pre>

<h3 id="col">col()</h3>

<p>Returns the specified column as a column vector.</p>

<p><strong>col( index )</strong></p>

<pre><code>var matrix = [[1,2],[3,4]];
jStat.col( matrix, 0 ) === [[1],[3]];</code></pre>

<p><strong>fn.col( index[, callback] )</strong></p>

<pre><code>jStat( matrix ).col( 0 ) === jStat([[1],[3]]);</code></pre>

<p>Or pass a callback to run the calculation asynchronously and pass on the calculation.
This allows for continued chaining of methods to the jStat object.
Also note <code>this</code> within the callback refers to the calling jStat object.</p>

<pre><code>jStat( matrix ).col( 0, function( d ) {
    // d === jStat([[1],[3]])
})</code></pre>

<h3 id="diag">diag()</h3>

<p>Returns the diagonal of a matrix.</p>

<p><strong>diag( array )</strong></p>

<pre><code>var matrix = [[1,2,3],[4,5,6],[7,8,9]];
jStat.diag( matrix ) === [[1],[5],[9]];</code></pre>

<p><strong>fn.diag( [callback] )</strong></p>

<pre><code>jStat( matrix ).diag() === jStat([[1],[5],[9]]);</code></pre>

<p>Or pass a callback to run the calculation asynchronously and pass on the calculation.
This allows for continued chaining of methods to the jStat object.
Also note <code>this</code> within the callback refers to the calling jStat object.</p>

<pre><code>jStat( matrix ).diag(function( d ) {
    // d === jStat([[1],[5],[9]])
});</code></pre>

<h3 id="antidiag">antidiag()</h3>

<p>Returns the anti-diagonal of the matrix.</p>

<p><strong>antidiag( array )</strong></p>

<pre><code>var matrix = [[1,2,3],[4,5,6],[7,8,9]];
jStat.antidiag( matrix ) === [[3],[5],[7]];</code></pre>

<p><strong>fn.antidiag( [callback] )</strong></p>

<pre><code>jStat( matrix ).antidiag() === jStat([[3],[5],[7]]);</code></pre>

<p>Or pass a callback to run the calculation asynchronously and pass on the calculation.
This allows for continued chaining of methods to the jStat object.
Also note <code>this</code> within the callback refers to the calling jStat object.</p>

<pre><code>jStat( matrix ).antidiag(function( d ) {
    // d === jStat([[3],[5],[7]])
});</code></pre>

<h3 id="transpose">transpose()</h3>

<p>Transpose a matrix.</p>

<p><strong>transpose( array )</strong></p>

<pre><code>var matrix = [[1,2],[3,4]];
jStat.transpose( matrix ) === [[1,3],[2,4]];</code></pre>

<p><strong>fn.transpose( [callback] )</strong></p>

<pre><code>jStat( matrix ).transpose() === [[1,3],[2,4]];</code></pre>

<p>Or pass a callback to run the calculation asynchronously and pass on the calculation.
This allows for continued chaining of methods to the jStat object.
Also note <code>this</code> within the callback refers to the calling jStat object.</p>

<pre><code>jStat( matrix ).transpose(function( d ) {
    // d === jStat([[1,3],[2,4]])
})</code></pre>

<h3 id="map">map( func )</h3>

<p>Map a function to all values and return a new object.</p>

<p><strong>map( array, fn )</strong></p>

<pre><code>var matrix = [[1,2],[3,4]];
jStat.map( matrix, function( x ) {
    return x * 2;
});
// returns [[2,4],[6,8]]</code></pre>

<p><strong>fn.map( fn )</strong></p>

<pre><code>jStat( matrix ).map(function( x ) {
    return x * 2;
});</code></pre>

<h3 id="alter">alter( func )</h3>

<p>Destructively map to an array.</p>

<p><strong>alter( array, fn )</strong></p>

<pre><code>var matrix = [[1,2],[3,4]];
jStat.alter( matrix, function( x ) {
    return x * 2;
});
// matrix === [[2,4],[6,8]]</code></pre>

<p><strong>fn.alter( fn )</strong></p>

<pre><code>var matrix = [[1,2],[3,4]];
jStat( matrix ).alter( function( x ) {
    return x * 2;
});</code></pre>

<h3 id="create">create()</h3>

<p>Create a row by col matrix using the supplied function
If <code>col</code> is omitted then it will default to value <code>row</code>.</p>

<p><strong>create( row[, col], fn )</strong></p>

<pre><code>jStat.create( 2, function( row, col ) {
    return row + col;
});
// returns [[0,1],[1,2]]</code></pre>

<p><strong>fn.create( row[, col], fn )</strong></p>

<p>Use this technique for creating matrices in jStat instances.</p>

<pre><code>jStat().create( 2, function( row, col ) {
    return row + col;
});
// returns jStat([[0,1],[1,2]])</code></pre>

<h3 id="zeros">zeros()</h3>

<p>Create a row by col matrix of all zeros.
If <code>col</code> is omitted then it will default to value <code>row</code>.</p>

<p><strong>zeros( row[, col] )</strong></p>

<pre><code>jStat.zeros( 2 );
// returns [[0,0],[0,0]]</code></pre>

<p><strong>fn.zeros( row[, col] )</strong></p>

<p>Use this technique for creating matrices in jStat instances.</p>

<pre><code>jStat().zeros( 2 );
// returns jStat([[0,0],[0,0]])</code></pre>

<h3 id="ones">ones()</h3>

<p>Create a row by col matrix of all ones.
If <code>col</code> is omitted then it will default to value <code>row</code>.</p>

<p><strong>ones( row[, col] )</strong></p>

<pre><code>jStat.zeros( 2 );
// returns [[0,0],[0,0]]</code></pre>

<p><strong>fn.ones( row[, col] )</strong></p>

<p>Use this technique for creating matrices in jStat instances.</p>

<pre><code>jStat().ones( 2 );
// returns jStat([[0,0],[0,0]])</code></pre>

<h3 id="rand">rand()</h3>

<p>Create a matrix of normally distributed random numbers.
If <code>col</code> is omitted then it will default to value <code>row</code>.</p>

<p><strong>rand( row[, col] )</strong></p>

<pre><code>jStat.rand( 3 );</code></pre>

<p><strong>fn.rand( row[, col] )</strong></p>

<p>Use this technique for creating matrices in jStat instances.</p>

<pre><code>jStat().rand( 3 );</code></pre>

<h3 id="identity">identity()</h3>

<p>Create an identity matrix of row by col.
If <code>col</code> is omitted then it will default to value <code>row</code>.</p>

<p><strong>identity( row[, col] )</strong></p>

<pre><code>jStat.identity( 2 );
// returns [[1,0],[0,1]]</code></pre>

<p><strong>fn.identity( row[, col] )</strong></p>

<p>Use this technique for creating matrices in jStat instances.</p>

<pre><code>jStat().identity( 2 );</code></pre>

<h3 id="clear">clear()</h3>

<p>Set all values in the vector or matrix to zero.</p>

<p><strong>clear( array )</strong></p>

<pre><code>var tmp = [1,2,3];
jStat.clear( tmp );
// tmp === [0,0,0]</code></pre>

<p><strong>fn.clear( [callback] )</strong></p>

<pre><code>jStat( 0, 1, 3 ).clear();
// returns [[0,0,0]]</code></pre>

<p>If a callback is passed then the original object is not altered</p>

<pre><code>var obj = jStat( 0, 1, 3 );
obj.clear(function() {
    // this === [ 0, 0, 0 ]
});
// obj === [ 0, 0.5, 1 ]</code></pre>

<h3 id="symmetric">symmetric()</h3>

<p>Tests if a matrix is symmetric.</p>

<p><strong>symmetric( array )</strong></p>

<pre><code>jStat.symmetric([[1,2],[2,1]]) === true</code></pre>

<p><strong>fn.symmetric( callback )</strong></p>

<pre><code>jStat([[1,2],[2,1]]).symmetric() === true</code></pre>

<p>Can pass a callback to maintain chainability</p>

<pre><code>jStat([[1,2],[2,1]]).symmetric(function( result ) {
    // result === true
});</code></pre>

<h2 id="jStat_Utility_Methods">jStat Utility Methods</h2>

<p>Utilities that are used throughout the jStat library</p>

<h3 id="utils.calcRdx">utils.calcRdx( num0, num1 )</h3>

<p>Calculate the decimal shift for the IEEE 754 floating point calculation correction.</p>

<h3 id="utils.isArray">utils.isArray( arg )</h3>

<p>Test if <code>arg</code> is an array.</p>

<h3 id="utils.isFunction">utils.isFunction( arg )</h3>

<p>Test if <code>arg</code> is a function.</p>

<h3 id="utils.isNumber">utils.isNumber( arg )</h3>

<p>Test if <code>arg</code> is a number and not <code>NaN</code>.</p>

<h2 id="vector_Functionality">Vector Functionality</h2>

<h3 id="sum">sum()</h3>

<p><strong>sum( array )</strong></p>

<p>Return the sum of a vector.</p>

<pre><code>jStat.sum([1,2,3]) === 6</code></pre>

<p><strong>fn.sum( [bool][,callback] )</strong></p>

<p>Return the sum of a vector or matrix columns.</p>

<pre><code>jStat( 1, 5, 5 ).sum() === 15
jStat([[1,2],[3,4]]).sum() === [ 4, 6 ]</code></pre>

<p>If callback is passed then will pass result as first argument.</p>

<pre><code>jStat( 1, 5, 5 ).sum(function( result ) {
    // result === 15
});</code></pre>

<p>If pass boolean true as first argument, then return sum of entire matrix.</p>

<pre><code>jStat([[1,2],[3,4]]).sum( true ) === 10</code></pre>

<p>And the two can be combined.</p>

<pre><code>jStat[[1,2],[3,4]]).sum(true,function( result ) {
    // result === 10
});</code></pre>

<h3 id="sumsqrd">sumsqrd()</h3>

<p><strong>sumsqrd( array )</strong></p>

<p>Return the sum squared of a vector.</p>

<pre><code>jStat.sumsqrd([1,2,3]) === 14</code></pre>

<p><strong>fn.sumsqrd( [bool][,callback] )</strong></p>

<p>Return the sum squared of a vector or matrix columns.</p>

<pre><code>jStat( 1, 5, 5 ).sumsqrd() === 55
jStat([[1,2],[3,4]]).sumsqrd() === [ 10, 20 ]</code></pre>

<p>If callback is passed then will pass result as first argument.</p>

<pre><code>jStat( 1, 5, 5 ).sumsqrd(function( result ) {
    // result === 55
});</code></pre>

<p>If pass boolean true as first argument, then return sum squared of entire matrix.</p>

<pre><code>jStat([[1,2],[3,4]]).sumsqrd( true ) === 650</code></pre>

<p>And the two can be combined.</p>

<pre><code>jStat[[1,2],[3,4]]).sumsqrd(true,function( result ) {
    // result === 650
});</code></pre>

<h3 id="sumsqerr">sumsqerr()</h3>

<p><strong>sumsqerr( array )</strong></p>

<p>Return the sum of squared errors of prediction of a vector.</p>

<pre><code>jStat.sumsqerr([1,2,3]) === 2</code></pre>

<p><strong>fn.sumsqerr( [bool][,callback] )</strong></p>

<p>Return the sum of squared errors of prediction of a vector or matrix columns.</p>

<pre><code>jStat( 1, 5, 5 ).sumsqerr() === 10
jStat([[1,2],[3,4]]).sumsqerr() === [ 2, 2 ]</code></pre>

<p>If callback is passed then will pass result as first argument.</p>

<pre><code>jStat( 1, 5, 5 ).sumsqerr(function( result ) {
    // result === 55
});</code></pre>

<p>If pass boolean true as first argument, then return sum of squared errors of entire matrix.</p>

<pre><code>jStat([[1,2],[3,4]]).sumsqerr( true ) === 0</code></pre>

<p>And the two can be combined.</p>

<pre><code>jStat[[1,2],[3,4]]).sumsqerr(true,function( result ) {
    // result === 0
});</code></pre>

<h3 id="product">product()</h3>

<p><strong>product( array )</strong></p>

<p>Return the product of a vector.</p>

<pre><code>jStat.product([1,2,3]) === 6</code></pre>

<p><strong>fn.product( [bool][,callback] )</strong></p>

<p>Return the product of a vector or matrix columns.</p>

<pre><code>jStat( 1, 5, 5 ).product() === 120
jStat([[1,2],[3,4]]).product() === [ 3, 8 ]</code></pre>

<p>If callback is passed then will pass result as first argument.</p>

<pre><code>jStat( 1, 5, 5 ).product(function( result ) {
    // result === 120
});</code></pre>

<p>If pass boolean true as first argument, then return sumsqerr of entire matrix.</p>

<pre><code>jStat([[1,2],[3,4]]).product( true ) === 24</code></pre>

<p>And the two can be combined.</p>

<pre><code>jStat[[1,2],[3,4]]).product(true,function( result ) {
    // result === 24
});</code></pre>

<h3 id="min">min()</h3>

<p><strong>min( array )</strong></p>

<p>Return the minimum value of a vector.</p>

<pre><code>jStat.min([1,2,3]) === 1</code></pre>

<p><strong>fn.min( [bool][,callback] )</strong></p>

<p>Return the minimum value of a vector or matrix columns.</p>

<pre><code>jStat( 1, 5, 5 ).min() === 1
jStat([[1,2],[3,4]]).min() === [ 1, 2 ]</code></pre>

<p>If callback is passed then will pass result as first argument.</p>

<pre><code>jStat( 1, 5, 5 ).min(function( result ) {
    // result === 1
});</code></pre>

<p>If pass boolean true as first argument, then return minimum of entire matrix.</p>

<pre><code>jStat([[1,2],[3,4]]).min( true ) === 1</code></pre>

<p>And the two can be combined.</p>

<pre><code>jStat[[1,2],[3,4]]).min(true,function( result ) {
    // result === 1
});</code></pre>

<h3 id="max">max()</h3>

<p><strong>max( array )</strong></p>

<p>Return the maximum value of a vector.</p>

<pre><code>jStat.max([1,2,3]) === 3</code></pre>

<p><strong>fn.max( [bool][,callback] )</strong></p>

<p>Return the maximum value of a vector or matrix columns.</p>

<pre><code>jStat( 1, 5, 5 ).max() === 5
jStat([[1,2],[3,4]]).max() === [ 3, 4 ]</code></pre>

<p>If callback is passed then will pass result as first argument.</p>

<pre><code>jStat( 1, 5, 5 ).max(function( result ) {
    // result === 5
});</code></pre>

<p>If pass boolean true as first argument, then return maximum of entire matrix.</p>

<pre><code>jStat([[1,2],[3,4]]).max( true ) === 4</code></pre>

<p>And the two can be combined.</p>

<pre><code>jStat[[1,2],[3,4]]).max(true,function( result ) {
    // result === 4
});</code></pre>

<h3 id="mean">mean()</h3>

<p><strong>mean( array )</strong></p>

<p>Return the mean of a vector.</p>

<pre><code>jStat.mean([1,2,3]) === 2</code></pre>

<p><strong>fn.max( [bool,][callback] )</strong></p>

<p>Return the mean of a vector or matrix columns.</p>

<pre><code>jStat( 1, 5, 5 ).mean() === 3
jStat([[1,2],[3,4]]).mean() === [ 2, 3 ]</code></pre>

<p>If callback is passed then will pass result as first argument.</p>

<pre><code>jStat( 1, 5, 5 ).mean(function( result ) {
    // result === 3
});</code></pre>

<p>If pass boolean true as first argument, then return mean of entire matrix.</p>

<pre><code>jStat([[1,2],[3,4]]).mean( true ) === 2.5</code></pre>

<p>And the two can be combined.</p>

<pre><code>jStat[[1,2],[3,4]]).mean(true,function( result ) {
    // result === 2.5
});</code></pre>

<h3 id="meansqerr">meansqerr()</h3>

<p><strong>meansqerr( array )</strong></p>

<p>Return the mean squared error of a vector.</p>

<pre><code>jStat.meansqerr([1,2,3]) === 0.66666...</code></pre>

<p><strong>fn.meansqerr( [bool][,callback] )</strong></p>

<p>Return the mean squared error of a vector or matrix columns.</p>

<pre><code>jStat( 1, 5, 5 ).meansqerr() === 2
jStat([[1,2],[3,4]]).meansqerr() === [ 1, 1 ]</code></pre>

<p>If callback is passed then will pass result as first argument.</p>

<pre><code>jStat( 1, 5, 5 ).meansqerr(function( result ) {
    // result === 2
});</code></pre>

<p>If pass boolean true as first argument, then return mean squared error of entire matrix.</p>

<pre><code>jStat([[1,2],[3,4]]).meansqerr( true ) === 0</code></pre>

<p>And the two can be combined.</p>

<pre><code>jStat[[1,2],[3,4]]).meansqerr(true,function( result ) {
    // result === 0
});</code></pre>

<h3 id="geomean">geomean()</h3>

<p><strong>geomean( array )</strong></p>

<p>Return the geometric mean of a vector.</p>

<pre><code>jStat.geomean([4,1,1/32]) === 0.5</code></pre>

<p><strong>fn.geomean( [bool][,callback] )</strong></p>

<p>Return the geometric mean of a vector or matrix columns.</p>

<pre><code>jStat([4,1,1\32]).geomean() === 0.5
jStat([[1,2],[3,4]]).geomean() === [ 1.732..., 2.828... ]</code></pre>

<p>If callback is passed then will pass result as first argument.</p>

<pre><code>jStat([4,1,1\32]).geomean(function( result ) {
    // result === 0.5
});</code></pre>

<p>If pass boolean true as first argument, then return geometric mean of entire matrix.</p>

<pre><code>jStat([[1,2],[3,4]]).geomean( true ) === 2.213...</code></pre>

<p>And the two can be combined.</p>

<pre><code>jStat[[1,2],[3,4]]).geomean(true,function( result ) {
    // result === 2.213...
});</code></pre>

<h3 id="median">median()</h3>

<p><strong>median( array )</strong></p>

<p>Return the median of a vector.</p>

<pre><code>jStat.median([1,2,3]) === 2</code></pre>

<p><strong>fn.median( [bool][,callback] )</strong></p>

<p>Return the median of a vector or matrix columns.</p>

<pre><code>jStat( 1, 5, 5 ).median() === 3
jStat([[1,2],[3,4]]).median() === [ 2, 3 ]</code></pre>

<p>If callback is passed then will pass result as first argument.</p>

<pre><code>jStat( 1, 5, 5 ).median(function( result ) {
    // result === 3
});</code></pre>

<p>If pass boolean true as first argument, then return median of entire matrix.</p>

<pre><code>jStat([[1,2],[3,4]]).median( true ) === 2.5</code></pre>

<p>And the two can be combined.</p>

<pre><code>jStat[[1,2],[3,4]]).median(true,function( result ) {
    // result === 2.5
});</code></pre>

<h3 id="cumsum">cumsum()</h3>

<p><strong>cumsum( array )</strong></p>

<p>Return an array of partial sums in the sequence.</p>

<pre><code>jStat.cumsum([1,2,3]) === [1,3,6]</code></pre>

<p><strong>fn.cumsum( [bool][,callback] )</strong></p>

<p>Return an array of partial sums for a vector or matrix columns.</p>

<pre><code>jStat( 1, 5, 5 ).cumsum() === [1,3,6,10,15]
jStat([[1,2],[3,4]]).cumsum() === [[1,4],[2,6]]</code></pre>

<p>If callback is passed then will pass result as first argument.</p>

<pre><code>jStat( 1, 5, 5 ).cumsum(function( result ) {
    // result === [1,3,6,10,15]
});</code></pre>

<p>If pass boolean true as first argument, then return cumulative sums of the matrix.</p>

<p><strong>Note:</strong> See <a href="https://github.com/jstat/jstat/issues/48">BUG #48</a></p>

<pre><code>jStat([[1,2],[3,4]]).cumsum( true ) === ...</code></pre>

<p>And the two can be combined.</p>

<pre><code>jStat([[1,2],[3,4]]).cumsum(true,function( result ) {
    // result === ...
});</code></pre>

<h3 id="diff">diff()</h3>

<p><strong>diff( array )</strong></p>

<p>Return an array of the successive differences of the array.</p>

<pre><code>jStat.diff([1,2,2,3]) === [1,0,1]</code></pre>

<p><strong>fn.diff( [bool][,callback] )</strong></p>

<p>Return an array of successive differences for a vector or matrix columns.</p>

<pre><code>jStat([1,2,2,3]).diff() === [1,0,1]
jStat([[1,2],[3,4],[1,4]]).diff() === [[2,-2],[2,0]]</code></pre>

<p>If callback is passed then will pass result as first argument.</p>

<pre><code>jStat([[1,2],[3,4],[1,4]]).diff(function( result ) {
    // result === [[2,-2],[2,0]]
});</code></pre>

<p>If pass boolean true as first argument, then return successive difference for the whole matrix.</p>

<pre><code>jStat([[1,2],[3,4],[1,4]]).diff(true) === [0,2]</code></pre>

<p>And the two can be combined.</p>

<pre><code>jStat([[1,2],[3,4],[1,4]]).diff(true,function( result ) {
    // result === [0,2]
});</code></pre>

<h3 id="mode">mode()</h3>

<p><strong>mode( array )</strong></p>

<p>Return the mode of a vector.
If there are multiple modes then <code>mode()</code> will return false.</p>

<p><strong>Note:</strong> There is a feature request to return an array if multiple modes exist
(<a href="https://github.com/jstat/jstat/issues/44" title="">Issue 44</a>).</p>

<pre><code>jStat.mode([1,2,2,3]) === 2
jStat.mode([1,2,3]) === false</code></pre>

<p><strong>fn.mode( [bool][,callback] )</strong></p>

<p>Return the mode for a vector or matrix columns.</p>

<pre><code>jStat([1,2,2,3]).mode() === 2
jStat([[1,2],[3,4],[1,4]]).mode() === [1,4]</code></pre>

<p>If callback is passed then will pass result as first argument.</p>

<pre><code>jStat( 1, 5, 5 ).mode(function( result ) {
    // result === false
});</code></pre>

<p>If pass boolean true as first argument, then return mode of the matrix.</p>

<p><strong>Note:</strong> See <a href="https://github.com/jstat/jstat/issues/50">BUG #50</a></p>

<pre><code>jStat([[1,2],[1,2]]).mode( true ) === false</code></pre>

<p>And the two can be combined.</p>

<pre><code>jStat[[1,2],[1,2]]).mode(true,function( result ) {
    // result === false
});</code></pre>

<h3 id="range">range()</h3>

<p><strong>range( array )</strong></p>

<p>Return the range of a vector</p>

<pre><code>jStat.range([1,2,3]) === 2</code></pre>

<p><strong>fn.range( [bool][,callback] )</strong></p>

<p>Return the range for a vector or matrix columns.</p>

<pre><code>jStat([1,2,3]).range() === 2
jStat([[1,2],[3,4]]).range() === [2,2]</code></pre>

<p>If callback is passed then will pass result as first argument.</p>

<pre><code>jStat( 1, 5, 5 ).range(function( result ) {
    // result === 4
});</code></pre>

<p>If pass boolean true as first argument, then return range of the matrix.</p>

<pre><code>jStat([[1,2],[3,5]]).range( true ) === true</code></pre>

<p>And the two can be combined.</p>

<pre><code>jStat[[1,2],[3,5]]).range(true,function( result ) {
    // result === 1
});</code></pre>

<h3 id="variance">variance()</h3>

<p><strong>variance( array[,flag])</strong></p>

<p>Return the variance of a vector.
Flag indicates whether to compute population or sample.</p>

<pre><code>jStat.variance([1,2,3,4]) === 1.25
jStat.variance([1,2,3,4],true) === 1.66666...</code></pre>

<p><strong>fn.variance( [bool][,callback] )</strong></p>

<p>Return the variance for a vector or matrix columns.</p>

<p><strong>Note:</strong> Cannot pass flag to indicate between population or sample for matrices.
There is a feature request for this on <a href="https://github.com/jstat/jstat/issues/51">Issue #51</a>.</p>

<pre><code>jStat([1,2,3,4]).variance() === 1.25
jStat([[1,2],[3,4]]).variance() === [1,1]</code></pre>

<p>If callback is passed then will pass result as first argument.</p>

<pre><code>jStat( 1, 5, 5 ).variance(function( result ) {
    // result === 2
});</code></pre>

<p>If pass boolean true as first argument, then return variance of the matrix.</p>

<pre><code>jStat([[1,2],[3,5]]).variance( true ) === 0.140625</code></pre>

<p>And the two can be combined.</p>

<pre><code>jStat[[1,2],[3,5]]).variance(true,function( result ) {
    // result === 0.140625
});</code></pre>

<h3 id="stdev">stdev()</h3>

<p><strong>stdev( array[,flag])</strong></p>

<p>Return the standard deviation of a vector.
Flag indicates whether to compute population or sample.</p>

<pre><code>jStat.stdev([1,2,3,4]) === 1.118...
jStat.stdev([1,2,3,4],true) === 1.290...</code></pre>

<p><strong>fn.stdev( [bool][,callback] )</strong></p>

<p>Return the standard deviation for a vector or matrix columns.</p>

<p><strong>Note:</strong> Cannot pass flag to indicate between population or sample for matrices.
There is a feature request for this on <a href="https://github.com/jstat/jstat/issues/51">Issue #51</a>.</p>

<pre><code>jStat([1,2,3,4]).stdev() === 1.118...
jStat([1,2,3,4]).stdev(true) === 1.290...
jStat([[1,2],[3,4]]).stdev() === [1,1]</code></pre>

<p>If callback is passed then will pass result as first argument.</p>

<pre><code>jStat( 1, 4, 4 ).stdev(function( result ) {
    // result === 1.118...
});
jStat( 1, 4, 4 ).stdev(true,function( result ) {
    // result === 1.290...
});</code></pre>

<p>If pass boolean true as first argument, then return variance of the matrix.</p>

<pre><code>jStat([[1,2],[3,5]]).stdev( true ) === 0.25</code></pre>

<p>And the two can be combined.</p>

<pre><code>jStat[[1,2],[3,5]]).stdev(true,function( result ) {
    // result === 0.25
});</code></pre>

<h3 id="meandev">meandev()</h3>

<p><strong>meandev( array )</strong></p>

<p>Return the mean absolute deviation of a vector.</p>

<pre><code>jStat.meandev([1,2,3,4]) === 1</code></pre>

<p><strong>fn.meandev( [bool][,callback] )</strong></p>

<p>Return the mean absolute deviation for a vector or matrix columns.</p>

<pre><code>jStat([1,2,3,4]).meandev() === 1
jStat([[1,2],[3,4]]).meandev() === [1,1]</code></pre>

<p>If callback is passed then will pass result as first argument.</p>

<pre><code>jStat( 1, 4, 4 ).meandev(function( result ) {
    // result === 1
});</code></pre>

<p>If pass boolean true as first argument, then return mean absolute deviation of the matrix.</p>

<pre><code>jStat([[1,2],[3,5]]).meandev( true ) === 0.25</code></pre>

<p>And the two can be combined.</p>

<pre><code>jStat[[1,2],[3,5]]).meandev(true,function( result ) {
    // result === 0.25
});</code></pre>

<h3 id="meddev">meddev()</h3>

<p><strong>meddev( array )</strong></p>

<p>Return the median absolute deviation of a vector.</p>

<pre><code>jStat.meddev([1,2,3,4]) === 1</code></pre>

<p><strong>fn.meddev( [bool][,callback] )</strong></p>

<p>Return the median absolute deviation for a vector or matrix columns.</p>

<pre><code>jStat([1,2,3,4]).meddev() === 1
jStat([[1,2],[3,4]]).meddev() === [1,1]</code></pre>

<p>If callback is passed then will pass result as first argument.</p>

<pre><code>jStat( 1, 4, 4 ).meddev(function( result ) {
    // result === 1
});</code></pre>

<p>If pass boolean true as first argument, then return median absolute deviation of the matrix.</p>

<pre><code>jStat([[1,2],[3,5]]).meddev( true ) === 0.25</code></pre>

<p>And the two can be combined.</p>

<pre><code>jStat[[1,2],[3,5]]).meddev(true,function( result ) {
    // result === 0.25
});</code></pre>

<h3 id="coeffvar">coeffvar()</h3>

<p><strong>coeffvar( array )</strong></p>

<p>Return the coefficient of variation of a vector.</p>

<pre><code>jStat.coeffvar([1,2,3,4]) === 0.447...</code></pre>

<p><strong>fn.coeffvar( [bool][,callback] )</strong></p>

<p>Return the coefficient of variation for a vector or matrix columns.</p>

<pre><code>jStat([1,2,3,4]).coeffvar() === 0.447...
jStat([[1,2],[3,4]]).coeffvar() === [0.5,0.333...]</code></pre>

<p>If callback is passed then will pass result as first argument.</p>

<pre><code>jStat( 1, 4, 4 ).coeffvar(function( result ) {
    // result === 0.447...
});</code></pre>

<p>If pass boolean true as first argument, then return coefficient of variation of the matrix.</p>

<pre><code>jStat([[1,2],[3,5]]).coeffvar( true ) === 0.142...</code></pre>

<p>And the two can be combined.</p>

<pre><code>jStat[[1,2],[3,5]]).coeffvar(true,function( result ) {
    // result === 0.142...
});</code></pre>

<h3 id="quartiles">quartiles()</h3>

<p><strong>quartiles( array )</strong></p>

<p>Return the quartiles of a vector.</p>

<pre><code>jStat.quartiles( jStat.seq(1,100,100)) === [25,50,75]</code></pre>

<p><strong>fn.quartiles( [callback] )</strong></p>

<p>Return the quartiles for a vector or matrix columns.</p>

<pre><code>jStat(1,100,100).quartiles() === [25,50,75]
jStat(1,100,100,function( x ) {
    return [x,x];
}).quartiles() === [[25,50,75],[25,50,75]]</code></pre>

<p>If callback is passed then will pass result as first argument.</p>

<pre><code>jStat(1,100,100).quartiles(function( result ) {
    // result === [25,50,75]
});</code></pre>

<h3 id="covariance">covariance()</h3>

<p><strong>covariance( array, array )</strong></p>

<p>Return the covariance of two vectors.</p>

<pre><code>var seq = jStat.seq( 0, 10, 11 );
jStat.covariance( seq, seq ) === 11;</code></pre>

<h3 id="corrcoeff">corrcoeff()</h3>

<p><strong>corrcoeff( array, array )</strong></p>

<p>Return the correlation coefficient of two vectors.</p>

<pre><code>var seq = jStat.seq( 0, 10, 11 );
jStat.corrcoeff( seq, seq ) === 1;</code></pre>

<h2 id="distributions">Distributions</h2>

<h3 id="jStat.beta">jStat.beta( alpha, beta )</h3>

<h4 id="jStat.beta.pdf">jStat.beta.pdf( x, alpha, beta )</h4>

<p>Returns the value of x in the Beta distribution with parameters alpha and beta.</p>

<h4 id="jStat.beta.cdf">jStat.beta.cdf( x, alpha, beta )</h4>

<p>Returns the value of x in the cdf for the Beta distribution with parameters alpha and beta.</p>

<h4 id="jStat.beta.inv">jStat.beta.inv( p, alpha, beta )</h4>

<p>Returns the value of p in the inverse of the cdf for the Beta distribution with parameters alpha and beta.</p>

<h4 id="jStat.beta.mean">jStat.beta.mean( alpha, beta )</h4>

<p>Returns the mean of the Beta distribution with parameters alpha and beta.</p>

<h4 id="jStat.beta.median">jStat.beta.median( alpha, beta )</h4>

<p>Returns the median of the Beta distribution with parameters alpha and beta.</p>

<h4 id="jStat.beta.mode">jStat.beta.mode( alpha, beta )</h4>

<p>Returns the mode of the Beta distribution with parameters alpha and beta.</p>

<h4 id="jStat.beta.sample">jStat.beta.sample( alpha, beta )</h4>

<p>Returns a random number whose distribution is the Beta distribution with parameters alpha and beta.</p>

<h4 id="jStat.beta.variance">jStat.beta.variance( alpha, beta )</h4>

<p>Returns the variance of the Beta distribution with parameters alpha and beta.</p>

<h3 id="jStat.centralF">jStat.centralF( df1, df2 )</h3>

<h4 id="jStat.centralF.pdf">jStat.centralF.pdf( x, df1, df2 )</h4>

<p>Returns the value of x in the pdf of the (Central) F distribution with numerator degrees of freedom df1 and denominator degrees of freedom df2.</p>

<h4 id="jStat.centralF.cdf">jStat.centralF.cdf( x, df1, df2 )</h4>

<p>Returns the value of x in the cdf of the (Central) F distribution with numerator degrees of freedom df1 and denominator degrees of freedom df2.</p>

<h4 id="jStat.centralF.inv">jStat.centralF.inv( x, df1, df2 )</h4>

<p>Returns the value of x in the inverse of the cdf for the (Central) F distribution with numerator degrees of freedom df1 and denominator degrees of freedom df2.</p>

<h4 id="jStat.centralF.mean">jStat.centralF.mean( df1, df2 )</h4>

<p>Returns the mean of the (Central) F distribution with numerator degrees of freedom df1 and denominator degrees of freedom df2.</p>

<h4 id="jStat.centralF.mode">jStat.centralF.mode( df1, df2 )</h4>

<p>Returns the mode of the (Central) F distribution with numerator degrees of freedom df1 and denominator degrees of freedom df2.</p>

<h4 id="jStat.centralF.sample">jStat.centralF.sample( df1, df2 )</h4>

<p>Returns a random number whose distribution is the (Central) F distribution with numerator degrees of freedom df1 and denominator degrees of freedom df2.</p>

<h4 id="jStat.centralF.variance">jStat.centralF.variance( df1, df2 )</h4>

<p>Returns the variance of the (Central) F distribution with numerator degrees of freedom df1 and denominator degrees of freedom df2.</p>

<h3 id="jStat.cauchy">jStat.cauchy( local, scale )</h3>

<h4 id="jStat.cauchy.pdf">jStat.cauchy.pdf( x, local, scale )</h4>

<p>Returns the value of x in the pdf of the Cauchy distribution with a location (median) of local and scale factor of scale.</p>

<h4 id="jStat.cauchy.cdf">jStat.cauchy.cdf( x, local, scale )</h4>

<p>Returns the value of x in the cdf of the Cauchy distribution with a location (median) of local and scale factor of scale.</p>

<h4 id="jStat.cauchy.inv">jStat.cauchy.inv( p, local, scale )</h4>

<p>Returns the value of p in the inverse of the cdf for the Cauchy distribution with a location (median) of local and scale factor of scale.</p>

<h4 id="jStat.cauchy.median">jStat.cauchy.median( local, scale )</h4>

<p>Returns the value of the median for the Cauchy distribution with a location (median) of local and scale factor of scale.</p>

<h4 id="jStat.cauchy.mode">jStat.cauchy.mode( local, scale )</h4>

<p>Returns the value of the mode for the Cauchy distribution with a location (median) of local and scale factor of scale.</p>

<h4 id="jStat.cauchy.sample">jStat.cauchy.sample( local, scale )</h4>

<p>Returns a random number whose distribution is the Cauchy distribution with a location (median) of local and scale factor of scale.</p>

<h4 id="jStat.cauchy.variance">jStat.cauchy.variance( local, scale )</h4>

<p>Returns the value of the variance for the Cauchy distribution with a location (median) of local and scale factor of scale.</p>

<h3 id="jStat.chisquare">jStat.chisquare( dof )</h3>

<h4 id="jStat.chisquare.pdf">jStat.chisquare.pdf( x, dof )</h4>

<p>Returns the value of x in the pdf of the Chi Square distribution with degrees of freedom dof.</p>

<h4 id="jStat.chisquare.cdf">jStat.chisquare.cdf( x, dof )</h4>

<p>Returns the value of x in the cdf of the Chi Square distribution with degrees of freedom dof.</p>

<h4 id="jStat.chisquare.inv">jStat.chisquare.inv( p, dof )</h4>

<p>Returns the value of x in the inverse of the cdf for the Chi Square distribution with degrees of freedom dof.</p>

<h4 id="jStat.chisquare.mean">jStat.chisquare.mean( dof )</h4>

<p>Returns the value of the mean for the Chi Square distribution with degrees of freedom dof.</p>

<h4 id="jStat.chisquare.median">jStat.chisquare.median( dof )</h4>

<p>Returns the value of the median for the Chi Square distribution with degrees of freedom dof.</p>

<h4 id="jStat.chisquare.mode">jStat.chisquare.mode( dof )</h4>

<p>Returns the value of the mode for the Chi Square distribution with degrees of freedom dof.</p>

<h4 id="jStat.chisquare.sample">jStat.chisquare.sample( dof )</h4>

<p>Returns a random number whose distribution is the Chi Square distribution with degrees of freedom dof.</p>

<h4 id="jStat.chisquare.variance">jStat.chisquare.variance( dof )</h4>

<p>Returns the value of the variance for the Chi Square distribution with degrees of freedom dof.</p>

<h3 id="jStat.exponential">jStat.exponential( rate )</h3>

<h4 id="jStat.exponential.pdf">jStat.exponential.pdf( x, rate )</h4>

<p>Returns the value of x in the pdf of the Exponential distribution with the parameter rate (lambda).</p>

<h4 id="jStat.exponential.cdf">jStat.exponential.cdf( x, rate )</h4>

<p>Returns the value of x in the cdf of the Exponential distribution with the parameter rate (lambda).</p>

<h4 id="jStat.exponential.inv">jStat.exponential.inv( rate )</h4>

<p>Returns the value of x in the inverse of the cdf for the Exponential distribution with the parameter rate (lambda).</p>

<h4 id="jStat.exponential.mean">jStat.exponential.mean( rate )</h4>

<p>Returns the value of the mean for the Exponential distribution with the parameter rate (lambda).</p>

<h4 id="jStat.exponential.median">jStat.exponential.median( rate )</h4>

<p>Returns the value of the median for the Exponential distribution with the parameter rate (lambda)</p>

<h4 id="jStat.exponential.mode">jStat.exponential.mode( rate )</h4>

<p>Returns the value of the mode for the Exponential distribution with the parameter rate (lambda).</p>

<h4 id="jStat.exponential.sample">jStat.exponential.sample( rate )</h4>

<p>Returns a random number whose distribution is the Exponential distribution with the parameter rate (lambda).</p>

<h4 id="jStat.exponential.variance">jStat.exponential.variance( rate )</h4>

<p>Returns the value of the variance for the Exponential distribution with the parameter rate (lambda).</p>

<h3 id="jStat.gamma">jStat.gamma( shape, scale )</h3>

<h4 id="jStat.gamma.pdf">jStat.gamma.pdf( x, shape, scale )</h4>

<p>Returns the value of x in the pdf of the Gamma distribution with the parameters shape (k) and scale (theta). Notice that if using the alpha beta convention, scale = 1/beta.</p>

<h4 id="jStat.gamma.cdf">jStat.gamma.cdf( x, shape, scale )</h4>

<p>Returns the value of x in the cdf of the Gamma distribution with the parameters shape (k) and scale (theta). Notice that if using the alpha beta convention, scale = 1/beta.</p>

<h4 id="jStat.gamma.inv">jStat.gamma.inv( p, shape, scale )</h4>

<p>Returns the value of p in the inverse of the cdf for the Gamma distribution with the parameters shape (k) and scale (theta). Notice that if using the alpha beta convention, scale = 1/beta.</p>

<h4 id="jStat.gamma.mean">jStat.gamma.mean( shape, scale )</h4>

<p>Returns the value of the mean for the Gamma distribution with the parameters shape (k) and scale (theta). Notice that if using the alpha beta convention, scale = 1/beta.</p>

<h4 id="jStat.gamma.mode">jStat.gamma.mode( shape, scale )</h4>

<p>Returns the value of the mode for the Gamma distribution with the parameters shape (k) and scale (theta). Notice that if using the alpha beta convention, scale = 1/beta.</p>

<h4 id="jStat.gamma.sample">jStat.gamma.sample( shape, scale )</h4>

<p>Returns a random number whose distribution is the Gamma distribution with the parameters shape (k) and scale (theta). Notice that if using the alpha beta convention, scale = 1/beta.</p>

<h4 id="jStat.gamma.variance">jStat.gamma.variance( shape, scale )</h4>

<p>Returns the value of the variance for the Gamma distribution with the parameters shape (k) and scale (theta). Notice that if using the alpha beta convention, scale = 1/beta.</p>

<h3 id="jStat.invgamma">jStat.invgamma( shape, scale )</h3>

<h4 id="jStat.invgamma.pdf">jStat.invgamma.pdf( x, shape, scale )</h4>

<p>Returns the value of x in the pdf of the Inverse-Gamma distribution with parametres shape (alpha) and scale (beta).</p>

<h4 id="jStat.invgamma.cdf">jStat.invgamma.cdf( x, shape, scale )</h4>

<p>Returns the value of x in the cdf of the Inverse-Gamma distribution with parametres shape (alpha) and scale (beta).</p>

<h4 id="jStat.invgamma.inv">jStat.invgamma.inv( p, shape, scale )</h4>

<p>Returns the value of p in the inverse of the cdf for the Inverse-Gamma distribution with parametres shape (alpha) and scale (beta).</p>

<h4 id="jStat.invgamma.mean">jStat.invgamma.mean( shape, scale )</h4>

<p>Returns the value of the mean for the Inverse-Gamma distribution with parametres shape (alpha) and scale (beta).</p>

<h4 id="jStat.invgamma.mode">jStat.invgamma.mode( shape, scale )</h4>

<p>Returns the value of the mode for the Inverse-Gamma distribution with parametres shape (alpha) and scale (beta).</p>

<h4 id="jStat.invgamma.sample">jStat.invgamma.sample( shape, scale )</h4>

<p>Returns a random number whose distribution is the Inverse-Gamma distribution with parametres shape (alpha) and scale (beta).</p>

<h4 id="jStat.invgamma.variance">jStat.invgamma.variance( shape, scale )</h4>

<p>Returns the value of the variance for the Inverse-Gamma distribution with parametres shape (alpha) and scale (beta).</p>

<h3 id="jStat.kumaraswamy">jStat.kumaraswamy( alpha, beta )</h3>

<h4 id="jStat.kumaraswamy.pdf">jStat.kumaraswamy.pdf( x, a, b )</h4>

<p>Returns the value of x in the pdf of the Kumaraswamy distribution with parameters a and b.</p>

<h4 id="jStat.kumaraswamy.cdf">jStat.kumaraswamy.cdf( x, alpha, beta )</h4>

<p>Returns the value of x in the cdf of the Kumaraswamy distribution with parameters a and b.</p>

<h4 id="jStat.kumaraswamy.mean">jStat.kumaraswamy.mean( alpha, beta )</h4>

<p>Returns the value of the mean of the Kumaraswamy distribution with parameters a and b.</p>

<h4 id="jStat.kumaraswamy.median">jStat.kumaraswamy.median( alpha, beta )</h4>

<p>Returns the value of the median of the Kumaraswamy distribution with parameters a and b.</p>

<h4 id="jStat.kumaraswamy.mode">jStat.kumaraswamy.mode( alpha, beta )</h4>

<p>Returns the value of the mode of the Kumaraswamy distribution with parameters a and b.</p>

<h4 id="jStat.kumaraswamy.variance">jStat.kumaraswamy.variance( alpha, beta )</h4>

<p>Returns the value of the variance of the Kumaraswamy distribution with parameters a and b.</p>

<h3 id="jStat.lognormal">jStat.lognormal( mu, sigma )</h3>

<h4 id="jStat.lognormal.pdf">jStat.lognormal.pdf( x, mu, sigma )</h4>

<p>Returns the value of x in the pdf of the Log-normal distribution with paramters mu (mean) and sigma (standard deviation).</p>

<h4 id="jStat.lognormal.cdf">jStat.lognormal.cdf( x, mu, sigma )</h4>

<p>Returns the value of x in the cdf of the Log-normal distribution with paramters mu (mean) and sigma (standard deviation).</p>

<h4 id="jStat.lognormal.inv">jStat.lognormal.inv( p, mu, sigma )</h4>

<p>Returns the value of x in the inverse of the cdf for the Log-normal distribution with paramters mu (mean of the Normal distribution) and sigma (standard deviation of the Normal distribution).</p>

<h4 id="jStat.lognormal.mean">jStat.lognormal.mean( mu, sigma )</h4>

<p>Returns the value of the mean for the Log-normal distribution with paramters mu (mean of the Normal distribution) and sigma (standard deviation of the Normal distribution).</p>

<h4 id="jStat.lognormal.median">jStat.lognormal.median( mu, sigma )</h4>

<p>Returns the value of the median for the Log-normal distribution with paramters mu (mean of the Normal distribution) and sigma (standard deviation of the Normal distribution).</p>

<h4 id="jStat.lognormal.mode">jStat.lognormal.mode( mu, sigma )</h4>

<p>Returns the value of the mode for the Log-normal distribution with paramters mu (mean of the Normal distribution) and sigma (standard deviation of the Normal distribution).</p>

<h4 id="jStat.lognormal.sample">jStat.lognormal.sample( mu, sigma )</h4>

<p>Returns a random number whose distribution is the Log-normal distribution with paramters mu (mean of the Normal distribution) and sigma (standard deviation of the Normal distribution).</p>

<h4 id="jStat.lognormal.variance">jStat.lognormal.variance( mu, sigma )</h4>

<p>Returns the value of the variance for the Log-normal distribution with paramters mu (mean of the Normal distribution) and sigma (standard deviation of the Normal distribution).</p>

<h3 id="jStat.normal">jStat.normal( mean, std )</h3>

<h4 id="jStat.normal.pdf">jStat.normal.pdf( x, mean, std )</h4>

<p>Returns the value of x in the pdf of the Normal distribution with parameters mean and std (standard deviation).</p>

<h4 id="jStat.normal.cdf">jStat.normal.cdf( x, mean, std )</h4>

<p>Returns the value of x in the cdf of the Normal distribution with parameters mean and std (standard deviation).</p>

<h4 id="jStat.normal.inv">jStat.normal.inv( p, mean, std )</h4>

<p>Returns the value of p in the inverse cdf for the Normal distribution with parameters mean and std (standard deviation).</p>

<h4 id="jStat.normal.mean">jStat.normal.mean( mean, std )</h4>

<p>Returns the value of the mean for the Normal distribution with parameters mean and std (standard deviation).</p>

<h4 id="jStat.normal.median">jStat.normal.median( mean, std )</h4>

<p>Returns the value of the median for the Normal distribution with parameters mean and std (standard deviation).</p>

<h4 id="jStat.normal.mode">jStat.normal.mode( mean, std )</h4>

<p>Returns the value of the mode for the Normal distribution with parameters mean and std (standard deviation).</p>

<h4 id="jStat.normal.sample">jStat.normal.sample( mean, std )</h4>

<p>Returns a random number whose distribution is the Normal distribution with parameters mean and std (standard deviation).</p>

<h4 id="jStat.normal.variance">jStat.normal.variance( mean, std )</h4>

<p>Returns the value of the variance for the Normal distribution with parameters mean and std (standard deviation).</p>

<h3 id="jStat.pareto">jStat.pareto( scale, shape )</h3>

<h4 id="jStat.pareto.pdf">jStat.pareto.pdf( x, scale, shape )</h4>

<p>Returns the value of x in the pdf of the Pareto distribution with parameters scale (x_m) and shape (alpha).</p>

<h4 id="jStat.pareto.cdf">jStat.pareto.cdf( x, scale, shape )</h4>

<p>Returns the value of x in the cdf of the Pareto distribution with parameters scale (x_m) and shape (alpha).</p>

<h4 id="jStat.pareto.mean">jStat.pareto.mean( scale, shape )</h4>

<p>Returns the value of the mean of the Pareto distribution with parameters scale (x_m) and shape (alpha).</p>

<h4 id="jStat.pareto.median">jStat.pareto.median( scale, shape )</h4>

<p>Returns the value of the median of the Pareto distribution with parameters scale (x_m) and shape (alpha).</p>

<h4 id="jStat.pareto.mode">jStat.pareto.mode( scale, shape )</h4>

<p>Returns the value of the mode of the Pareto distribution with parameters scale (x_m) and shape (alpha).</p>

<h4 id="jStat.pareto.variance">jStat.pareto.variance( scale, shape )</h4>

<p>Returns the value of the variance of the Pareto distribution with parameters scale (x_m) and shape (alpha).</p>

<h3 id="jStat.studentt">jStat.studentt( dof )</h3>

<h4 id="jStat.studentt.pdf">jStat.studentt.pdf( x, dof )</h4>

<p>Returns the value of x in the pdf of the Student&#39;s T distribution with degrees of freedom dof.</p>

<h4 id="jStat.studentt.cdf">jStat.studentt.cdf( x, dof )</h4>

<p>Returns the value of x in the cdf of the Student&#39;s T distribution with degrees of freedom dof.</p>

<h4 id="jStat.studentt.inv">jStat.studentt.inv( p, dof )</h4>

<p>Returns the value of p in the inverse of the cdf for the Student&#39;s T distribution with degrees of freedom dof.</p>

<h4 id="jStat.studentt.mean">jStat.studentt.mean( dof )</h4>

<p>Returns the value of the mean of the Student&#39;s T distribution with degrees of freedom dof.</p>

<h4 id="jStat.studentt.median">jStat.studentt.median( dof )</h4>

<p>Returns the value of the median of the Student&#39;s T distribution with degrees of freedom dof.</p>

<h4 id="jStat.studentt.mode">jStat.studentt.mode( dof )</h4>

<p>Returns the value of the mode of the Student&#39;s T distribution with degrees of freedom dof.</p>

<h4 id="jStat.studentt.sample">jStat.studentt.sample( dof )</h4>

<p>Returns a random number whose distribution is the Student&#39;s T distribution with degrees of freedom dof.</p>

<h4 id="jStat.studentt.variance">jStat.studentt.variance( dof )</h4>

<p>Returns the value of the variance for the Student&#39;s T distribution with degrees of freedom dof.</p>

<h3 id="jStat.weibull">jStat.weibull( scale, shape )</h3>

<h4 id="jStat.weibull.pdf">jStat.weibull.pdf( x, scale, shape )</h4>

<p>Returns the value x in the pdf for the Weibull distribution with parameters scale (lambda) and shape (k).</p>

<h4 id="jStat.weibull.cdf">jStat.weibull.cdf( x, scale, shape )</h4>

<p>Returns the value x in the cdf for the Weibull distribution with parameters scale (lambda) and shape (k).</p>

<h4 id="jStat.weibull.inv">jStat.weibull.inv( p, scale, shape )</h4>

<p>Returns the value of x in the inverse of the cdf for the Weibull distribution with parameters scale (lambda) and shape (k).</p>

<h4 id="jStat.weibull.mean">jStat.weibull.mean( scale, shape )</h4>

<p>Returns the value of the mean of the Weibull distribution with parameters scale (lambda) and shape (k).</p>

<h4 id="jStat.weibull.median">jStat.weibull.median( scale, shape )</h4>

<p>Returns the value of the median of the Weibull distribution with parameters scale (lambda) and shape (k).</p>

<h4 id="jStat.weibull.mode">jStat.weibull.mode( scale, shape )</h4>

<p>Returns the mode of the Weibull distribution with parameters scale (lambda) and shape (k).</p>

<h4 id="jStat.weibull.sample">jStat.weibull.sample( scale, shape )</h4>

<p>Returns a random number whose distribution is the Weibull distribution with parameters scale (lambda) and shape (k).</p>

<h4 id="jStat.weibull.variance">jStat.weibull.variance( scale, shape )</h4>

<p>Returns the variance of the Weibull distribution with parameters scale (lambda) and shape (k).</p>

<h3 id="jStat.uniform">jStat.uniform( a, b )</h3>

<h4 id="jStat.uniform.pdf">jStat.uniform.pdf( x, a, b )</h4>

<p>Returns the value of x in the pdf of the Uniform distribution from a to b.</p>

<h4 id="jStat.uniform.cdf">jStat.uniform.cdf( x, a, b )</h4>

<p>Returns the value of x in the cdf of the Uniform distribution from a to b.</p>

<h4 id="jStat.uniform.mean">jStat.uniform.mean( a, b )</h4>

<p>Returns the value of the mean of the Uniform distribution from a to b.</p>

<h4 id="jStat.uniform.median">jStat.uniform.median( a, b )</h4>

<p>Returns the value of the median of the Uniform distribution from a to b.</p>

<h4 id="jStat.uniform.mode">jStat.uniform.mode( a, b )</h4>

<p>Returns the value of the mode of the Uniform distribution from a to b.</p>

<h4 id="jStat.uniform.sample">jStat.uniform.sample( a, b )</h4>

<p>Returns a random number whose distribution is the Uniform distribution from a to b.</p>

<h4 id="jStat.uniform.variance">jStat.uniform.variance( a, b )</h4>

<p>Returns the variance of the Uniform distribution from a to b.</p>

<h3 id="jStat.binomial">jStat.binomial</h3>

<h4 id="jStat.binomial.pdf">jStat.binomial.pdf( k, n, p )</h4>

<p>Returns the value of k in the pdf of the Binomial distribution with parameters n and p.</p>

<h4 id="jStat.binomial.cdf">jStat.binomial.cdf( k, n, p )</h4>

<p>Returns the value of k in the cdf of the Binomial distribution with parameters n and p.</p>

<h3 id="jStat.negbin">jStat.negbin</h3>

<h4 id="jStat.negbin.pdf">jStat.negbin.pdf( k, r, p )</h4>

<p>Returns the value of k in the pdf of the Negative Binomial distribution with parameters n and p.</p>

<h4 id="jStat.negbin.cdf">jStat.negbin.cdf( x, r, p )</h4>

<p>Returns the value of x in the cdf of the Negative Binomial distribution with parameters n and p.</p>

<h3 id="jStat.hypgeom">jStat.hypgeom</h3>

<h4 id="jStat.hypgeom.pdf">jStat.hypgeom.pdf( k, N, m, n )</h4>

<p>Returns the value of k in the pdf of the Hypergeometric distribution with parameters N (the population size), m (the success rate), and n (the number of draws).
#### jStat.hypgeom.cdf( x, N, m, n )</p>

<p>Returns the value of k in the pdf of the Hypergeometric distribution with parameters N (the population size), m (the success rate), and n (the number of draws).</p>

<h3 id="jStat.poisson">jStat.poisson</h3>

<h4 id="jStat.poisson.pdf">jStat.poisson.pdf( k, l )</h4>

<p>Returns the value of k in the pdf of the Poisson distribution with parameter l (lambda).</p>

<h4 id="jStat.poisson.cdf">jStat.poisson.cdf( x, l )</h4>

<p>Returns the value of x in the cdf of the Poisson distribution with parameter l (lambda).</p>

<h3 id="jStat.triangular">jStat.triangular</h3>

<h4 id="jStat.triangular.pdf">jStat.triangular.pdf( x, a, b, c )</h4>

<p>Returns the value of x in the pdf of the Triangular distribution with the parameters a, b, and c.</p>

<h4 id="jStat.triangular.cdf">jStat.triangular.cdf( x, a, b, c )</h4>

<p>Returns the value of x in the cdf of the Triangular distribution with the parameters a, b, and c.</p>

<h4 id="jStat.triangular.mean">jStat.triangular.mean( a, b, c )</h4>

<p>Returns the value of the mean of the Triangular distribution with the parameters a, b, and c.</p>

<h4 id="jStat.triangular.median">jStat.triangular.median( a, b, c )</h4>

<p>Returns the value of the median of the Triangular distribution with the parameters a, b, and c.</p>

<h4 id="jStat.triangular.mode">jStat.triangular.mode( a, b, c )</h4>

<p>Returns the value of the mode of the Triangular distribution with the parameters a, b, and c.</p>

<h4 id="jStat.triangular.variance">jStat.triangular.variance( a, b, c )</h4>

<p>Returns the value of the variance of the Triangular distribution with the parameters a, b, and c.</p>

<h2 id="special_Functions">Special Functions</h2>

<h3 id="betafn">betafn( x, y )</h3>

<p>Evaluates the Beta function at (x,y).</p>

<h3 id="betaln">betaln( x, y )</h3>

<p>Evaluates the log Beta function at (x,y).</p>

<h3 id="betacf">betacf( x, a, b )</h3>

<p>Returns the continued fraction for the incomplete Beta function with parameters a and b modified by Lentz&#39;s method evaluated at x.</p>

<h3 id="ibetainv">ibetainv( p, a, b)</h3>

<p>Returns the inverse of the incomplete Beta function evaluated at (p,a,b).</p>

<h3 id="ibeta">ibeta( x, a, b)</h3>

<p>Returns teh incomplete Beta function evaluated at (x,a,b).</p>

<h3 id="gammaln">gammaln( x )</h3>

<p>Returns the Log-Gamma function evaluated at x.</p>

<h3 id="gammafn">gammafn( x )</h3>

<p>Returns the Gamma function evaluated at x.</p>

<h3 id="gammap">gammap( a, x )</h3>

<p>Returns the Lower Incomplete Gamma function evaluated at (a,x).</p>

<h3 id="factorialln">factorialln( n )</h3>

<p>Returns the natural log factorial of n.</p>

<h3 id="factorial">factorial( n )</h3>

<p>Returns the factorial of n.</p>

<h3 id="combination">combination( n, m )</h3>

<p>Returns the number of combinations of n, m.</p>

<h3 id="permutation">permutation( n, m )</h3>

<p>Returns the number of permutations of n, m.</p>

<h3 id="gammapinv">gammapinv( p, a )</h3>

<p>Returns the inverse of the incomplete Gamma function evaluated at (p,a).</p>

<h3 id="erf">erf( x )</h3>

<p>Returns the error function evaluated at x. </p>

<h3 id="erfc">erfc( x )</h3>

<p>Returns the complementary error function evaluated at x.</p>

<h3 id="erfcinv">erfcinv( p )</h3>

<p>Returns the inverse of the complementary error function evaluated at p.</p>

<h3 id="randn">randn( n, m )</h3>

<p>Returns a normal deviate (mean 0 and standard deviation 1).</p>

<h3 id="randg">randg( shape, n, m )</h3>

<p>Returns a Gamma deviate by the method of Marsaglia and Tsang.</p>

<h2 id="linear_Algebra">Linear Algebra</h2>

<h2 id="instance_Functionality">Instance Functionality</h2>

<h3 id="add">add( arg )</h3>

<p>Add value to all entries.</p>

<pre><code>jStat([[1,2,3]]).add( 2 ) === [[3,4,5]];</code></pre>

<h3 id="subtract">subtract( arg )</h3>

<p>Subtract all entries by value.</p>

<pre><code>jStat([[4,5,6]]).subtract( 2 ) === [[2,3,4]];</code></pre>

<h3 id="divide">divide( arg )</h3>

<p>Divide all entries by value.</p>

<pre><code>jStat([[2,4,6]]).divide( 2 ) === [[1,2,3]];</code></pre>

<h3 id="multiply">multiply( arg )</h3>

<p>Multiply all entries by value.</p>

<pre><code>jStat([[1,2,3]]).multiply( 2 ) === [[2,4,6]];</code></pre>

<h3 id="dot">dot( arg )</h3>

<p>Take dot product.</p>

<h3 id="pow">pow( arg )</h3>

<p>Raise all entries by value.</p>

<pre><code>jStat([[1,2,3]]).pow( 2 ) === [[1,4,9]];</code></pre>

<h3 id="abs">abs()</h3>

<p>Return the absolute values of all entries.</p>

<pre><code>jStat([[1,-2,-3]]).abs() === [[1,2,3]];</code></pre>

<h3 id="norm">norm()</h3>

<p>Compulte the norm of a vector.</p>

<h3 id="angle">angle( arg )</h3>

<p>Compute the angle between two vectors.</p>

<h2 id="static_Functionality">Static Functionality</h2>

<h3 id="add">add( arr, arg )</h3>

<p>Add arg to all entries of the array</p>

<h3 id="subtract">subtract( arr, arg )</h3>

<p>Subtract all entries of the array by arg</p>

<h3 id="divide">divide( arr, arg )</h3>

<p>Divide all entries of the array by arg.</p>

<h3 id="multiply">multiply( arr, arg )</h3>

<p>Multiply all entries of the array by arg.</p>

<h3 id="dot">dot( arr1, arr2 )</h3>

<p>Take dot product of array 1 and array 2.</p>

<h3 id="pow">pow( arr, arg )</h3>

<p>Raise all entries of the array to the power of arg</p>

<h3 id="abs">abs(arr)</h3>

<p>Return the absolute values of all entries in the array</p>

<h3 id="norm">norm(arr)</h3>

<p>Compulte the norm of a vector.</p>

<h3 id="angle">angle( arr1, arr2 )</h3>

<p>Compute the angle between two vectors.</p>

<h3 id="aug">aug(A,B)</h3>

<p>Augments matrix A by matrix B</p>

<h3 id="det">det(A)</h3>

<p>Calculates the determinant of matrix A.</p>

<h3 id="inv">inv(A)</h3>

<p>Returns the inverse of the matrix A.</p>

<h3 id="gauss_elimination">gauss_elimination(A,B)</h3>

<p>Performs Gaussian Elimination on matrix A augmented by matrix B.</p>

<h3 id="gauss_jordan">gauss_jordan(A,B)</h3>

<p>Performs Gauss-Jordan Elimination on matrix A augmented by matrix B.</p>

<h3 id="lu">lu(A,B)</h3>

<p>Performs the LU-Decomposition on matrix A.</p>

<h3 id="cholesky">cholesky(A)</h3>

<p>Performs the Cholesky decomposition on matrix A.</p>

<h3 id="gauss_jacobi">gauss_jacobi(A,b,x,r)</h3>

<p>Solves the linear system Ax = b using the Gauss-Jacobi method with an initial guess of r. </p>

<h3 id="gauss_seidel">gauss_seidel(A,b,x,r)</h3>

<p>Solves the linear system Ax = b using the Gauss-Seidel method with an initial guess of r.</p>

<h3 id="sOR">SOR(A,b,x,r,w)</h3>

<p>Solves the linear system Ax = b using the sucessive over-relaxation method with an initial guess of r and parameter w (omega).</p>

<h3 id="householder">householder(A)</h3>

<p>Performs the householder transformation on the matrix A.</p>

<h3 id="qR">QR()</h3>

<h3 id="jacobi">jacobi()</h3>

<h3 id="rungekutta">rungekutta()</h3>

<h3 id="romberg">romberg()</h3>

<h3 id="richardson">richardson()</h3>

<h3 id="simpson">simpson()</h3>

<h3 id="hermite">hermite()</h3>

<h3 id="lagrange">lagrange()</h3>

<h3 id="cubic_spline">cubic_spline()</h3>

<h3 id="gauss_quadrature">gauss_quadrature()</h3>

<h3 id="pCA">PCA()</h3>

<h2 id="statistical_Tests">Statistical Tests</h2>

<p>The test module includes methods that enact popular statistical tests.
The tests that are implemented are Z tests, T tests, and F tests.
Also included are methods for developing confidence intervals. Currently
regression is not included but it should be included soon (once matrix
inversion is fixed).</p>

<h2 id="statistics_Instance_Functionality">Statistics Instance Functionality</h2>

<h3 id="zscore">zscore( value[, flag])</h3>

<p>Returns the z-score of the value taking the jStat object as the observed
values. Flag==true denotes use of sample standard deviation.</p>

<h3 id="ztest">ztest( value, sides[, flag])</h3>

<p>Returns the p-value of the value taking the jStat object as the observed
values. Sides is an integer value 1 or 2 denoting a 1 or 2 sided z-test.
The test defaults to a 2 sided z-test if sides is not specified.Flag==true
denotes use of sample standard devaition.</p>

<h3 id="tscore">tscore( value)</h3>

<p>Returns the t-score of the value taking the jStat object as the observed
values.</p>

<h3 id="ttest">ttest( value, sides)</h3>

<p>Returns the p-value of the value taking the jStat object as the observed
values. Sides is an integer value 1 or 2 denoting a 1 or 2 sided t-test.
The test defaults to a 2 sided t-test if sides is not specified.</p>

<h3 id="anovafscore">anovafscore()</h3>

<p>Returns the f-score of the ANOVA test on the arrays of the jStat object.</p>

<h3 id="anovaftest">anovaftest()</h3>

<p>Returns the p-value of an ANOVA test on the arrays of the jStat object.</p>

<h2 id="static_Methods">Static Methods</h2>

<h2 id="z_Statistics">Z Statistics</h2>

<h3 id="jStat.zscore">jStat.zscore( value, mean, sd)</h3>

<p>Returns the z-score of value given the mean and the standard deviation
of the test.</p>

<h3 id="jStat.zscore">jStat.zscore( value, array[, flag])</h3>

<p>Returns the z-score of value given the data from array. Flag==true denotes
use of the sample standard deviation.</p>

<h3 id="jStat.ztest">jStat.ztest( value, mean, sd, sides)</h3>

<p>Returns the p-value of a the z-test of value given the mean and standard
deviation of the test. Sides is an integer value 1 or 2 denoting a
one or two sided z-test. If sides is not specified the test defaults
to a two sided z-test.</p>

<h3 id="jStat.ztest">jStat.ztest( zscore, sides)</h3>

<p>Returns the p-value of the z-score. Sides is an integer value 1 or 2
denoting a one or two sided z-test. If sides is not specified the test
defaults to a two sided z-test</p>

<h3 id="jStat.ztest">jStat.ztest( value, array, sides[, flag])</h3>

<p>Returns the p-value of value given the data from the array. Sides is
an integer value 1 or 2 denoting a one or two sided z-test. If sides
is not specified the test defaults to a two sided z-test. flag==true
denotes the use of the sample standard deviation.</p>

<h2 id="t_Statistics">T Statistics</h2>

<h3 id="jStat.tscore">jStat.tscore( value, mean, sd, n)</h3>

<p>Returns the t-score of the value given the mean, standard deviation,
and the sample size n.</p>

<h3 id="jStat.tscore">jStat.tscore( value, array)</h3>

<p>Returns the t-score of value given the data from the array.</p>

<h3 id="jStat.ttest">jStat.ttest( value, mean, sd, n, sides)</h3>

<p>Returns the p-value of value given the mean, standard deviation,
and the sample size n. Sides is an integer value 1 or 2 denoting
a one or two sided t-test. If sides is not specified the test
defaults to a two sided t-test.</p>

<h3 id="jStat.ttest">jStat.ttest( tscore, n, sides)</h3>

<p>Returns the p-value of the t-score given the sample size n. Sides 
is an integer value 1 or 2 denoting a one or two sided t-test. 
If sides is not specified the test defaults to a two sided t-test. </p>

<h3 id="jStat.ttest">jStat.ttest( value, array, sides)</h3>

<p>Returns the p-value of the value given the data in the array.
Sides is an integer value 1 or 2 denoting a one or two sided 
t-test. If sides is not specified the test defaults to a two 
sided t-test.</p>

<h2 id="f_Statistics">F Statistics</h2>

<h3 id="jStat.anovafscore">jStat.anovafscore( array1, array2, ..., arrayn)</h3>

<p>Returns the f-score of an ANOVA on the arrays.</p>

<h3 id="jStat.anovafscore">jStat.anovafscore( [array1,array2, ...,arrayn])</h3>

<p>Returns the f-score of an ANOVA on the arrays.</p>

<h3 id="jStat.anovaftest">jStat.anovaftest( array1, array2, ...., arrayn)</h3>

<p>Returns the p-value of the f-statistic from the ANOVA
test on the arrays.</p>

<h3 id="jStat.ftest">jStat.ftest( fscore, df1, df2)</h3>

<p>Returns the p-value for the fscore with a numerator degress
of freedom df1 and the denominator degrees of freedom df2</p>

<h2 id="confidence_Intervals">Confidence Intervals</h2>

<h3 id="jStat.normalci">jStat.normalci( value, alpha, sd, n)</h3>

<p>Returns a 1-alpha confidence interval for the value given
a normal distribution with a standard deviation sd and a
sample size n</p>

<h3 id="jStat.normalci">jStat.normalci( value, alpha, array)</h3>

<p>Returns a 1-alpha confidence interval for the value given
a normal distribution in the data from the array.</p>

<h3 id="jStat.tci">jStat.tci( value, alpha, sd, n)</h3>

<p>Returns a 1-alpha confidence interval for the value given
the standard deviation and the sample size n.</p>

<h3 id="jStat.tci">jStat.tci( value, alpha, array)</h3>

<p>Returns a 1-alpha confidence interval for the value given
the data from the array.</p>
	</div>
	<script src="assets/sh_main.js"></script>
	<script src="assets/sh_javascript.min.js"></script>
	<script>highlight(undefined, undefined, 'pre');</script>
</body>
</html>
